# 對我來說 Async 算什麼

## Container

在開始講 RxJS 之前，要先講 container 的概念。  
至於什麼是 container，就要去 google 一下別人寫的相對專業的 FP 文章來看了，比如說 [Mostly Adequate Guide 的第 8 章]。  
當然對 FP 沒概念的人可能需要往前讀 1 ~ 7 章來建構一下基礎像是 pure function 之類的東西。  
該第 8 章舉了很多例子，像是 Maybe, Either, IO, Task 可以應對 no value, error, side effect, async 的情況。  
如果你看了這四種例子之後有一種感覺：啊不是都一樣的東西嗎？就是換個頭，換個尾，其他都一樣。  
沒錯，這就是我們想要的東西！

是否你有經驗是寫好一版的程式，之後因為需求或者是依賴的東西換了，導致你全部的東西需要全改？  
像是原本是可以直接拿到的值，現在突然要改成用 API 才可以拿到，突然間 sync 變 async 把流程都毀了。  
但如果當初寫程式是像第 8 章那樣用某種 container 包起來，當需求變成值要從 API 拿的話，只要：

1. 換頭，把 container 用 Task 包起來。
1. 換尾，把取值的方式改成對應的取值方式。

其他的一切都照原本的流程運作，這就是它的好處之一。

## Observable

而 Observable 也是一種 container，一但你把資料透過 RxJS 的方式包成 Observable，不管是 sync 還是 async，處理的方式都一樣，所以只要學好 RxJS 就可以無視那些變化，連頭尾都不用改了。  
當你在學習 RxJS 的過程可能會碰到一些困擾，畢竟它的寫程式的思路已經跟以前不一樣了。如果你用 RxJS 但還是保留以前的思路的話，那你寫出來的程式會長得跟以前幾乎一樣，只是換個 library 幫你做事而已。  
因為公司是寫 Vue 2 ，我就用 Vue 2 作為例子吧。

### 範例 1

```js
{
  data() {
    return {
      value: 0,
    };
  },
  computed: {
    checkout() {
      return `$${this.value * 1.1}`;
    },
  },
  methods: {
    add(n) {
      this.value += n;
    },
    reset() {
      this.value = 0;
    },
  },
}
```

你可以想像這是個 POS 系統，有些地方點了可以讓你加錢，然後有些地方可以顯示金額，甚至是加了 10% 服務費後的金額，還有個可以歸 0 的功能。  
這種傳統的寫法讀起來會很不容易，因為它基本上得跳著讀，一下看這區塊，一下看那區塊的。像是會改到 `value` 的有兩個區塊，會使用到 `value` 的有三個區塊，且是無序的，你得跳著看完再組合出可能運作的順序出來。  
實際功能不會這麼簡陋，你可能還想要換頁，是不是你就會做一系列類似的事情讓它可以 page +1 -1 之類的。  
這時候不管是 data, computed, methods 的區塊都會塞滿各式各樣，且彼此可能不相關的程式碼參雜在一起，而且全部一樣是跳著讀，還會讀到跟自己想追的東西不相關的程式碼。  
最慘的就是得用搜尋關鍵字的方式來找，一切萬惡的根源就是竄改 `value` 這個行為，因為這個行為散落在各地，導致各區都可能會影響最後顯示在畫面上的值。  
所以要減低這個困擾，就是要限制操作人員，統一窗口，只讓一個 function 會去改 `value`，這樣我們只要看這個統一窗口用了哪些 function 再去追這些特定的 function 就好了。  
儘管這樣做還是得跳著讀，但至少已經可以減少大部分的困擾，因為所有可能都集中在這個窗口，只要追這些有限的 function 就好了。  
如果用 RxJS 呢？

### 範例 2

```js
{
  observableMethods: ["add", "reset"],
  subscriptions() {
    const onAdd = this.add$.pipe(
      scan((a, b) => a + b, 0),
      takeUntil(this.reset$),
      repeat()
    );

    const onReset = this.reset$.pipe(map(() => 0));

    const value = merge(onAdd, onReset);

    const valueWithTip = value.pipe(
      map((x) => x * 1.1),
      map((x) => `$${x}`)
    );

    return {
      valueWithTip,
    };
  },
}
```

如果你用 RxJS 寫出來的版本還是有 `this.value =` 且散布各地的話，那就會是像我講的只是把 RxJS 當成某種操作資料的手段而已，而沒有把思路轉為流的樣子。  
所謂流就是~~川楓~~ stream，像是 WebSocket, event 等，是一種源源不絕一直會有東西進來的形容。  
這種流的思路就像川一樣可以匯集來自各處的河流，最終流向大海，就是所謂畫面上顯示值的地方。所以只要沿著這個出海口往高處尋，就可以找到各處的水源。  
在這種設計之下畫面上各對應的值跟我們所做出來的流是 1 比 1 的，也就是達到了統一窗口的效果，而且沿著流往上找的一定會是相關支線，不可能會出現在下方。  
而且就因為這是個流，不管這個 `add$` 或是 `reset$` 是來自使用者、API，甚至是 WebSocket 之類的都可以，流程上都不用改。  
所以如果你的產品是監控系列的，需要有實時反饋的畫面之類的都很適合用 RxJS 處理，自由的混用 HTTP 得到初始值，然後透過 WebSocket 實時更新，完全不需要透過 `this.value =` 這種方式去改變值，只要把各種源頭匯集起來處理就好了。

讀這種流的設計是倒著讀的，我們先在畫面上找到要追的那個值，發現它是 `valueWithTip`，所以回到程式碼裡面找到這個出海口。  
看到這個出海口其實是來自一個 `value` 的流，只是把它加上一成服務費之後並格式化成$的樣子。  
而 `value` 是由兩條流匯集而成，分別是 `onAdd` 跟 `onRest`，並且不多做事，流下來什麼就傳什麼下去。  
`onReset` 就是一個當 `this.reset$`發生時會給你 0。 而`onAdd`是一個會從0開始累加的功能，且在`this.reset$` 發生時會重算。  
這就是整個流的過程，如過你有做其他功能也是像這樣追就可以了，不用散落各地找，沿著流往上尋即可。

## 有限與無限

看完後你會發現其實寫程式的方式沒有差太多，像是歸零的行為就是把 0 丟出去，累加的行為還是做累加，差別在於我們並不會寫死說這個行為會綁在 `value` 上，而是讓這個行為被需要的流去匯集，跟 FP 的概念有點像，交給需要的人去決定，我們只決定過程而已。  
而裡面有個較特別的是 `onAdd` 這件事，因為這邊用到了有限與無限的轉換。

當你在讀 RxJS 相關文章時可能會看見一些 cold 或 hot 的 Observable，這些資訊固然重要，但我認為更重要的是有限跟無限的概念。  
所謂的**有限**就是可預期何時結束的流，像是 HTTP 就是一個來回，array 就是把裡面都跑完就結束了。  
所謂的**無限**就是永遠不會結束的，像是各種事件的觸發，或是 WebSocket，就是不知道什麼時候會有值進來，也不知道什麼時候會沒值。  
有些 operator 只能用在有限的情況，所以如果你串在無限的流裡面就會發現完全沒效果，像是 `last()`, `isEmpty()`, `max()` 這類的東西，如果不是有限就會不知道何時結束，只要還沒結束就沒辦法做出對應的動作。  
而 `repeat()` 就是用在有限的情況，因為只有結束的當下才能重複再做一次。 所以我們為了讓無限的 `this.add$` 轉變成有限，所以設定結束點為 `takeUntil(this.reset$)`。但是結束後 `this.add$` 再觸發就會被忽略，因為已經結束了。所以要加上 `repeat()` 來讓它重新接回 `this.add$` 這個流。

## Cold and Hot

而 cold 跟 hot 是指當我們共用同一個名字的流時，到底是不是同一個流？  
預設大部分的流都是 Cold，也就是獨立的流。假設我們現在有另一個畫面要顯示美元的樣子，那我們會：

```js
const usDollar = value.pipe(...);
```

這時我們是共用了同一個名字的流叫做 `value` 但其實他是獨立的，也就是 `valueWithTip` 跟 `usDollar` 會得到各自長得跟 `value` 一模一樣的來源，所以事實上他們上頭是各自做一模一樣的事情，也就是運算方面也會是各自算一模一樣的東西。  
所以為了節省這種不必要的重複動作，我們可以透過 `share()` 或 `shareReplay()` 把 `value` 轉成 Hot 就可以共用同一個流，這樣只要算一次就可以給下面不同的流使用。  
而實際情況冷熱都還是會用到，必須看你的情境作應對。

## 附註

範例 2 是配合一個叫 [vue-rx] 的 Vue 2 plugin 來使用，因為畢竟 Vue 2 的設計關係終究還是得有個地方去做 `this.value =` 的動作，只是我們透過這個 plugin 來幫我們做這件事而達到統一窗口的好處。  
而且 Observable 是需要 subscribe 跟 unsubscribe 的動作，這邊也是由 plugin 幫我們統一處理，所以程式才可以相對簡潔。  
儘管相對簡潔了，程式碼還是會比傳統的寫法多，這是正常的。因為我們為了長期維護的好處，所以需要做一些程式面的設計導致要多寫一些程式碼來符合這個設計，但我相信好讀好維護的程式遠比簡短而不好維護的程式來的好。

說到好讀易理解這件事要再提出一個我個人的觀點，看不懂的程式分兩種：

1. 每塊程式碼我都看得懂，但我就是看不懂你程式是在寫什麼。這就是程式設計的不好，流程複雜、到處竄改，需要在腦中記住運算的結果來接續其他塊的程式碼導致不易閱讀。
1. 沒概念，不知從何看起，像天書一樣。這就是道行不夠，可能是 library 不熟，沒接觸過這種程式設計的方式等。

如果是情況 1 基本上可以判定是設計不良，當然批評別人以前你要先能提出更好的設計來讓它更好讀。  
如果是情況 2 則是必須去了解 library 或是該設計模式，一開始當然會不好讀，畢竟沒見過。了解後才能去評斷這樣的設計好或不好。  
所以看不懂的程式碼不要急著評論它或是拒絕它，會這樣寫一定是有它的原因，至於原因是好是壞得先去理解對方再去評論會比較好。

[mostly adequate guide 的第 8 章]: https://mostly-adequate.gitbook.io/mostly-adequate-guide/ch08
[vue-rx]: https://github.com/vuejs/vue-rx
